import React, { useRef, useLayoutEffect, useState } from 'react';
import { useSpring, animated } from '@react-spring/web';
import { useWindowSize } from './useWindowSize';

const settings = {
  maxTilt: 25,
  rotationPower: 50,
  swipeThreshold: 0.5
};

const physics = {
  touchResponsive: {
    friction: 50,
    tension: 2000
  },
  animateOut: {
    friction: 30,
    tension: 400
  },
  animateBack: {
    friction: 10,
    tension: 200
  }
};

const pythagoras = (x, y) => {
  return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
};

const normalize = (vector) => {
  const length = Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));
  return { x: vector.x / length, y: vector.y / length };
};

const TinderCard = React.forwardRef(
  (
    { flickOnSwipe = true, children, onSwipe, onCardLeftScreen, className, preventSwipe = [], swipeRequirementType = 'velocity', swipeThreshold = settings.swipeThreshold, onSwipeRequirementFulfilled, onSwipeRequirementUnfulfilled },
    ref
  ) => {
    const { width, height } = useWindowSize();
    const [{ xyrot }, setSpringTarget] = useSpring(() => ({
      xyrot: [0, 0, 0],
      config: physics.touchResponsive
    }));

    const element = useRef();
    const [isClicking, setIsClicking] = useState(false);

    settings.swipeThreshold = swipeThreshold;

    React.useImperativeHandle(ref, () => ({
      async swipe (dir = 'right') {
        if (onSwipe) onSwipe(dir);
        const power = 1.3;
        const disturbance = (Math.random() - 0.5) / 2;
        if (dir === 'right') {
          await animateOut({ x: power, y: disturbance });
        } else if (dir === 'left') {
          await animateOut({ x: -power, y: disturbance });
        } else if (dir === 'up') {
          await animateOut({ x: disturbance, y: -power });
        } else if (dir === 'down') {
          await animateOut({ x: disturbance, y: power });
        }
        if (onCardLeftScreen) onCardLeftScreen(dir);
      },
      async restoreCard () {
        await animateBack();
      }
    }));

    const handleSwipeReleased = React.useCallback(
      async (gesture) => {
        const dir = getSwipeDirection({
          x: swipeRequirementType === 'velocity' ? gesture.vx : gesture.dx,
          y: swipeRequirementType === 'velocity' ? gesture.vy : gesture.dy
        });

        if (dir !== 'none') {
          if (flickOnSwipe) {
            if (!preventSwipe.includes(dir)) {
              if (onSwipe) onSwipe(dir);

              await animateOut(swipeRequirementType === 'velocity' ? ({
                x: gesture.vx,
                y: gesture.vy
              }) : (
                normalize({ x: gesture.dx, y: gesture.dy })
              ));
              if (onCardLeftScreen) onCardLeftScreen(dir);
              return;
            }
          }
        }

        animateBack();
      },
      [swipeRequirementType, flickOnSwipe, preventSwipe, onSwipe, onCardLeftScreen]
    );

    const gestureStateFromWebEvent = (ev, startPositon, lastPosition, isTouch) => {
      let dx = isTouch ? ev.touches[0].clientX - startPositon.x : ev.clientX - startPositon.x;
      let dy = isTouch ? ev.touches[0].clientY - startPositon.y : ev.clientY - startPositon.y;

      if (startPositon.x === 0 && startPositon.y === 0) {
        dx = 0;
        dy = 0;
      }

      const vx = -(dx - lastPosition.dx) / (lastPosition.timeStamp - Date.now());
      const vy = -(dy - lastPosition.dy) / (lastPosition.timeStamp - Date.now());

      const gestureState = { dx, dy, vx, vy, timeStamp: Date.now() };
      return gestureState;
    };

    useLayoutEffect(() => {
      let startPositon = { x: 0, y: 0 };
      let lastPosition = { dx: 0, dy: 0, vx: 0, vy: 0, timeStamp: Date.now() };

      const onTouchStart = (ev) => {
        if (!ev.srcElement.className.includes('pressable') && ev.cancelable) {
          ev.preventDefault();
        }

        const gestureState = gestureStateFromWebEvent(ev, startPositon, lastPosition, true);
        lastPosition = gestureState;
        startPositon = { x: ev.touches[0].clientX, y: ev.touches[0].clientY };
      };

      element.current.addEventListener(('touchstart'), onTouchStart);

      const onMouseDown = (ev) => {
        setIsClicking(true);
        const gestureState = gestureStateFromWebEvent(ev, startPositon, lastPosition, false);
        lastPosition = gestureState;
        startPositon = { x: ev.clientX, y: ev.clientY };
      };

      element.current.addEventListener(('mousedown'), onMouseDown);

      const handleMove = (gestureState) => {
        let rot = gestureState.vx * 15;
        if (isNaN(rot)) rot = 0;
        rot = Math.max(Math.min(rot, settings.maxTilt), -settings.maxTilt);
        setSpringTarget.start({ xyrot: [gestureState.dx, gestureState.dy, rot], config: physics.touchResponsive });
      };

      const onMouseMove = (ev) => {
        if (!isClicking) return;
        const gestureState = gestureStateFromWebEvent(ev, startPositon, lastPosition, false);
        lastPosition = gestureState;
        handleMove(gestureState);
      };

      window.addEventListener(('mousemove'), onMouseMove);

      const onMouseUp = (ev) => {
        if (!isClicking) return;
        setIsClicking(false);
        handleSwipeReleased(lastPosition);
        startPositon = { x: 0, y: 0 };
        lastPosition = { dx: 0, dy: 0, vx: 0, vy: 0, timeStamp: Date.now() };
      };

      window.addEventListener(('mouseup'), onMouseUp);

      const onTouchMove = (ev) => {
        const gestureState = gestureStateFromWebEvent(ev, startPositon, lastPosition, true);
        lastPosition = gestureState;
        handleMove(gestureState);
      };

      element.current.addEventListener(('touchmove'), onTouchMove);

      const onTouchEnd = (ev) => {
        handleSwipeReleased(lastPosition);
        startPositon = { x: 0, y: 0 };
        lastPosition = { dx: 0, dy: 0, vx: 0, vy: 0, timeStamp: Date.now() };
      };

      element.current.addEventListener(('touchend'), onTouchEnd);

      return () => {
        element.current.removeEventListener(('touchstart'), onTouchStart);
        element.current.removeEventListener(('touchmove'), onTouchMove);
        element.current.removeEventListener(('touchend'), onTouchEnd);
        window.removeEventListener(('mousemove'), onMouseMove);
        window.removeEventListener(('mouseup'), onMouseUp);
        element.current.removeEventListener(('mousedown'), onMouseDown);
      };
    }, [handleSwipeReleased, setSpringTarget]);

    return (
      React.createElement(animated.div, {
        ref: element,
        className,
        style: {
          transform: xyrot.to((x, y, rot) => `translate3d(${x}px, ${y}px, ${0}px) rotate(${rot}deg)`)
        },
        children
      })
    );
  }
);

export default TinderCard;
